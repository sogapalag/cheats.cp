{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Competitive programming cheat sheets. As short as possible to get core idea correctly.","title":"Intro"},{"location":"ds/treap/","text":"(key, priority) s.t. key hold tree property, (randomized)priority hold heap property. Claim. When order and priority determined, treap struture uniquely fixed. Non-rotate treap \u00b6 split : split into two treaps by some key. s.t. keys(left) < < key \\leq \\leq keys(right). merge : merge two treaps into one by priority heapify. Use above two basic operations to retain treap property, we can achieve other tree operations. Lazy, range reverse \u00b6 split_by_size : as said. However we use treap mostly in this fashion, index [n] implicitly as key to build initial treap. Then doing reverse will destory (index-key)tree property, but (randomized)priority almost ensure balance still. get rank/position of original index after some reverse. method 1. for the chain that node to root, accum left size decided by each edge is left or right. method 2. maintain u=min(l,r) and erase min when monotonic, special case.","title":"Treap"},{"location":"ds/treap/#non-rotate-treap","text":"split : split into two treaps by some key. s.t. keys(left) < < key \\leq \\leq keys(right). merge : merge two treaps into one by priority heapify. Use above two basic operations to retain treap property, we can achieve other tree operations.","title":"Non-rotate treap"},{"location":"ds/treap/#lazy-range-reverse","text":"split_by_size : as said. However we use treap mostly in this fashion, index [n] implicitly as key to build initial treap. Then doing reverse will destory (index-key)tree property, but (randomized)priority almost ensure balance still. get rank/position of original index after some reverse. method 1. for the chain that node to root, accum left size decided by each edge is left or right. method 2. maintain u=min(l,r) and erase min when monotonic, special case.","title":"Lazy, range reverse"},{"location":"math/crt/","text":"Solve a a for a \\equiv a_i (\\mod p_i) a \\equiv a_i (\\mod p_i) , coprime \\gcd(p_i,p_j)=1, \\forall i,j \\gcd(p_i,p_j)=1, \\forall i,j . Claim 1. \\exists \\exists unique a (\\mod P) a (\\mod P) , where P = \\prod p_i P = \\prod p_i . Claim 2. a = \\sum a_ib_ib_i' a = \\sum a_ib_ib_i' , where b_i = P/p_i b_i = P/p_i , b_i' = b_i^{-1} (\\mod p_i) b_i' = b_i^{-1} (\\mod p_i) . Extended crt \u00b6 Fold with start (0,1) (0,1) , (a,p) (a,p) by next (a_1,p_1) (a_1,p_1) . Claim. a := a + p p' \\dfrac{a_1-a}{\\gcd(p,p_1)} a := a + p p' \\dfrac{a_1-a}{\\gcd(p,p_1)} , when a_1-a \\equiv 0(\\mod g) a_1-a \\equiv 0(\\mod g) . Proof. Replace pp'=g-p_1p_1' pp'=g-p_1p_1' , result symmetry form a_1 + (0 \\mod p_1) a_1 + (0 \\mod p_1) .","title":"Chinese remainder theorem"},{"location":"math/crt/#extended-crt","text":"Fold with start (0,1) (0,1) , (a,p) (a,p) by next (a_1,p_1) (a_1,p_1) . Claim. a := a + p p' \\dfrac{a_1-a}{\\gcd(p,p_1)} a := a + p p' \\dfrac{a_1-a}{\\gcd(p,p_1)} , when a_1-a \\equiv 0(\\mod g) a_1-a \\equiv 0(\\mod g) . Proof. Replace pp'=g-p_1p_1' pp'=g-p_1p_1' , result symmetry form a_1 + (0 \\mod p_1) a_1 + (0 \\mod p_1) .","title":"Extended crt"},{"location":"math/exgcd/","text":"Solve ax+by = \\gcd(a,b) ax+by = \\gcd(a,b) . With implicitly knowing solution bx' + (a \\mod b)y' = g bx' + (a \\mod b)y' = g , and with a\\mod b = a - \\lfloor\\dfrac{a}{b}\\rfloor b a\\mod b = a - \\lfloor\\dfrac{a}{b}\\rfloor b . Rearrange coefficients: \\Rightarrow x = y', y = x' - y'\\cdot \\lfloor\\dfrac{a}{b}\\rfloor \\Rightarrow x = y', y = x' - y'\\cdot \\lfloor\\dfrac{a}{b}\\rfloor","title":"Extended gcd"},{"location":"math/sieve/","text":"Linear \u00b6 Break when hit least prime factor. Claim. Each composite sieved once corresponding to its least prime. Multiplicative function : f(mn) = f(m)f(n) f(mn) = f(m)f(n) , for coprime m,n m,n . f(ip) f(ip) \\phi \\phi \\mu \\mu \\sigma_k \\sigma_k e_k e_k p\\nmid i p\\nmid i (p-1)\\phi(i) (p-1)\\phi(i) -\\mu(i) -\\mu(i) (1+p^k)\\sigma_k(i) (1+p^k)\\sigma_k(i) 1+p^k 1+p^k p\\mid i p\\mid i p\\phi(i) p\\phi(i) 0 0 \\sigma_k(i) e_k(ip)/e_k(i) \\sigma_k(i) e_k(ip)/e_k(i) 1 + e_k(i)*p^k 1 + e_k(i)*p^k Where e_{k,p}(p^c) = 1 + p^k + p^{2k} + \\cdots + p^{ck} e_{k,p}(p^c) = 1 + p^k + p^{2k} + \\cdots + p^{ck} , a non-multy helper function. Thus we can build above functions in linear time. Prefix of multiplicative functions \u00b6 Usage. Find F(n)=\\sum f(i) F(n)=\\sum f(i) . Dirichlet ring . Divisor sum identities . When f*g f*g is easy to calculate: \\begin{align} \\sum_{i=1}^n (f*g)(i) = \\sum_{i=1}^n F\\left(\\left\\lfloor \\dfrac{n}{i} \\right\\rfloor\\right) g(i) \\\\\\\\ \\Rightarrow F(n) \\sim (F\\left(\\left\\lfloor \\dfrac{n}{2} \\right\\rfloor\\right),\\cdots) \\end{align} \\begin{align} \\sum_{i=1}^n (f*g)(i) = \\sum_{i=1}^n F\\left(\\left\\lfloor \\dfrac{n}{i} \\right\\rfloor\\right) g(i) \\\\\\\\ \\Rightarrow F(n) \\sim (F\\left(\\left\\lfloor \\dfrac{n}{2} \\right\\rfloor\\right),\\cdots) \\end{align} On prime factorization \u00b6 Implicitly ignore f(i=1)=1 f(i=1)=1 . Usage. Find F F when f(p^c) f(p^c) easy to calculate. Notation. p_1=2,p_2=3,p_3=5,... p_1=2,p_2=3,p_3=5,... ; p_s = \\max \\{p: p \\leq \\sqrt{n} \\} p_s = \\max \\{p: p \\leq \\sqrt{n} \\} . Define. S_k = \\{x: p_i\\nmid x, \\forall i\\leq k\\} S_k = \\{x: p_i\\nmid x, \\forall i\\leq k\\} . i.e. remain number sieved after first k k primes. $$ [n] = S_0 \\supset S_1 = {\\text{odd number}} \\supset S_2 \\supset \\cdots S_s = \\{ p: p > \\sqrt{n} \\} $$ Zhou \u00b6 Let F_k(n) = \\sum_{i\\in S_k} f(i) F_k(n) = \\sum_{i\\in S_k} f(i) . Recurrence relation: \\begin{align} F(n) &= F_0(n) = \\sum_i f(i) \\\\ F_k(n) &= F_{k-1}(n) - f(p_k) F_{k-1} \\left(\\left\\lfloor \\dfrac{n}{p_k} \\right\\rfloor\\right) \\\\ &= \\begin{cases} F_{k-1}(n), p_k^2 > n \\\\ \\cdots \\end{cases} \\end{align} Thus we can calculate $$ \\sum_{\\exists p > \\sqrt{n}, p\\mid i} f(i) = \\sum_{i=1}^{\\sqrt{n}} f(i)F_{s}\\left(\\left\\lfloor\\dfrac{n}{i} \\right\\rfloor \\right) $$ Similarily we can define H_k(n)= \\sum_{i \\sim (p_k..p_s]} f(i) H_k(n)= \\sum_{i \\sim (p_k..p_s]} f(i) , to calculate remain part. Min_25 \u00b6 Usage. Count number of primes, \\pi(n) \\pi(n) . Let G_k(n) = \\sum_{S_k \\cup P} g(i) G_k(n) = \\sum_{S_k \\cup P} g(i) . Similarily: $$ G_k(n) = G_{k-1}(n) - g(p_k) \\left(G_{k-1} \\left(\\left\\lfloor \\dfrac{n}{p_k} \\right\\rfloor\\right) - G_{k-1}(p_{k-1}) \\right) $$ Set g=1 g=1 , thus \\pi(n) = G_s(n) \\pi(n) = G_s(n) . Meissel\u2013Lehmer \u00b6","title":"Sieve"},{"location":"math/sieve/#linear","text":"Break when hit least prime factor. Claim. Each composite sieved once corresponding to its least prime. Multiplicative function : f(mn) = f(m)f(n) f(mn) = f(m)f(n) , for coprime m,n m,n . f(ip) f(ip) \\phi \\phi \\mu \\mu \\sigma_k \\sigma_k e_k e_k p\\nmid i p\\nmid i (p-1)\\phi(i) (p-1)\\phi(i) -\\mu(i) -\\mu(i) (1+p^k)\\sigma_k(i) (1+p^k)\\sigma_k(i) 1+p^k 1+p^k p\\mid i p\\mid i p\\phi(i) p\\phi(i) 0 0 \\sigma_k(i) e_k(ip)/e_k(i) \\sigma_k(i) e_k(ip)/e_k(i) 1 + e_k(i)*p^k 1 + e_k(i)*p^k Where e_{k,p}(p^c) = 1 + p^k + p^{2k} + \\cdots + p^{ck} e_{k,p}(p^c) = 1 + p^k + p^{2k} + \\cdots + p^{ck} , a non-multy helper function. Thus we can build above functions in linear time.","title":"Linear"},{"location":"math/sieve/#prefix-of-multiplicative-functions","text":"Usage. Find F(n)=\\sum f(i) F(n)=\\sum f(i) . Dirichlet ring . Divisor sum identities . When f*g f*g is easy to calculate: \\begin{align} \\sum_{i=1}^n (f*g)(i) = \\sum_{i=1}^n F\\left(\\left\\lfloor \\dfrac{n}{i} \\right\\rfloor\\right) g(i) \\\\\\\\ \\Rightarrow F(n) \\sim (F\\left(\\left\\lfloor \\dfrac{n}{2} \\right\\rfloor\\right),\\cdots) \\end{align} \\begin{align} \\sum_{i=1}^n (f*g)(i) = \\sum_{i=1}^n F\\left(\\left\\lfloor \\dfrac{n}{i} \\right\\rfloor\\right) g(i) \\\\\\\\ \\Rightarrow F(n) \\sim (F\\left(\\left\\lfloor \\dfrac{n}{2} \\right\\rfloor\\right),\\cdots) \\end{align}","title":"Prefix of multiplicative functions"},{"location":"math/sieve/#on-prime-factorization","text":"Implicitly ignore f(i=1)=1 f(i=1)=1 . Usage. Find F F when f(p^c) f(p^c) easy to calculate. Notation. p_1=2,p_2=3,p_3=5,... p_1=2,p_2=3,p_3=5,... ; p_s = \\max \\{p: p \\leq \\sqrt{n} \\} p_s = \\max \\{p: p \\leq \\sqrt{n} \\} . Define. S_k = \\{x: p_i\\nmid x, \\forall i\\leq k\\} S_k = \\{x: p_i\\nmid x, \\forall i\\leq k\\} . i.e. remain number sieved after first k k primes. $$ [n] = S_0 \\supset S_1 = {\\text{odd number}} \\supset S_2 \\supset \\cdots S_s = \\{ p: p > \\sqrt{n} \\} $$","title":"On prime factorization"},{"location":"math/sieve/#zhou","text":"Let F_k(n) = \\sum_{i\\in S_k} f(i) F_k(n) = \\sum_{i\\in S_k} f(i) . Recurrence relation: \\begin{align} F(n) &= F_0(n) = \\sum_i f(i) \\\\ F_k(n) &= F_{k-1}(n) - f(p_k) F_{k-1} \\left(\\left\\lfloor \\dfrac{n}{p_k} \\right\\rfloor\\right) \\\\ &= \\begin{cases} F_{k-1}(n), p_k^2 > n \\\\ \\cdots \\end{cases} \\end{align} Thus we can calculate $$ \\sum_{\\exists p > \\sqrt{n}, p\\mid i} f(i) = \\sum_{i=1}^{\\sqrt{n}} f(i)F_{s}\\left(\\left\\lfloor\\dfrac{n}{i} \\right\\rfloor \\right) $$ Similarily we can define H_k(n)= \\sum_{i \\sim (p_k..p_s]} f(i) H_k(n)= \\sum_{i \\sim (p_k..p_s]} f(i) , to calculate remain part.","title":"Zhou"},{"location":"math/sieve/#min_25","text":"Usage. Count number of primes, \\pi(n) \\pi(n) . Let G_k(n) = \\sum_{S_k \\cup P} g(i) G_k(n) = \\sum_{S_k \\cup P} g(i) . Similarily: $$ G_k(n) = G_{k-1}(n) - g(p_k) \\left(G_{k-1} \\left(\\left\\lfloor \\dfrac{n}{p_k} \\right\\rfloor\\right) - G_{k-1}(p_{k-1}) \\right) $$ Set g=1 g=1 , thus \\pi(n) = G_s(n) \\pi(n) = G_s(n) .","title":"Min_25"},{"location":"math/sieve/#meissellehmer","text":"","title":"Meissel\u2013Lehmer"},{"location":"string/suffix_array/","text":"Usage \u00b6 Sort suffix strings s[i..] of s , store i s in sa . View. Suffix trie/tree, by the help of lcp array. Append 0 to s , thus could treat length <k <k still be k k as cyclic string. k=1,2,4,8... k=1,2,4,8... , sort all length =k =k . By compare (i, i+k) as key corresponding to (s[i..i+k], s[i+k..i+2k]) . O( n\\log^2 n n\\log^2 n ). Radix sort (i,i+k) by counting sort. O( n\\log n n\\log n ). Kasai's . Build lcp/height array, i.e. lcp of adjacents(rank). Claim. Adjacents(original)'s lcp(i+1) >= lcp(i)-1 , where lcp(i) = lcp[rk[i]] . Claim 1. lcp of rank l and r is \\min_{i=l..r} \\text{lcp}[i] \\min_{i=l..r} \\text{lcp}[i] . Applications \u00b6 #distinct substrings. i.e. #nodes in trie. = n(n+1)/2 - \\sum_i \\text{lcp}[i] = n(n+1)/2 - \\sum_i \\text{lcp}[i] . Longest length among substrings occurence > k > k . = \\max_i \\min \\text{lcp}[i..i+k] = \\max_i \\min \\text{lcp}[i..i+k] . Lcp of 3 or more strings. Concat S_1\\#_1 S_2\\#_2 S_3 \\#_3 S_1\\#_1 S_2\\#_2 S_3 \\#_3 . Z's algorithm also work.","title":"Suffix array"},{"location":"string/suffix_array/#usage","text":"Sort suffix strings s[i..] of s , store i s in sa . View. Suffix trie/tree, by the help of lcp array. Append 0 to s , thus could treat length <k <k still be k k as cyclic string. k=1,2,4,8... k=1,2,4,8... , sort all length =k =k . By compare (i, i+k) as key corresponding to (s[i..i+k], s[i+k..i+2k]) . O( n\\log^2 n n\\log^2 n ). Radix sort (i,i+k) by counting sort. O( n\\log n n\\log n ). Kasai's . Build lcp/height array, i.e. lcp of adjacents(rank). Claim. Adjacents(original)'s lcp(i+1) >= lcp(i)-1 , where lcp(i) = lcp[rk[i]] . Claim 1. lcp of rank l and r is \\min_{i=l..r} \\text{lcp}[i] \\min_{i=l..r} \\text{lcp}[i] .","title":"Usage"},{"location":"string/suffix_array/#applications","text":"#distinct substrings. i.e. #nodes in trie. = n(n+1)/2 - \\sum_i \\text{lcp}[i] = n(n+1)/2 - \\sum_i \\text{lcp}[i] . Longest length among substrings occurence > k > k . = \\max_i \\min \\text{lcp}[i..i+k] = \\max_i \\min \\text{lcp}[i..i+k] . Lcp of 3 or more strings. Concat S_1\\#_1 S_2\\#_2 S_3 \\#_3 S_1\\#_1 S_2\\#_2 S_3 \\#_3 . Z's algorithm also work.","title":"Applications"}]}