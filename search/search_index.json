{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Cheat sheets of competitive programming. As short as possible to get core idea correctly.","title":"Intro"},{"location":"ds/treap.html","text":"(key, priority) s.t. key hold tree property, (randomized)priority hold heap property. Claim. When order and priority determined, treap struture uniquely fixed. Non-rotate treap \u00b6 split : split into two treaps by some key. s.t. keys(left) < < key \\leq \\leq keys(right). merge : merge two treaps into one by priority heapify. Use above two basic operations to retain treap property, we can achieve other tree operations. Lazy, range reverse \u00b6 split_by_size : as said. However we use treap mostly in this fashion, index [n] implicitly as key to build initial treap. Then doing reverse will destory (index-key)tree property, but (randomized)priority almost ensure balance still. get rank/position of original index after some reverse. method 1. for the chain that node to root, accum left size decided by each edge is left or right. method 2. maintain u=min(l,r) and erase min when monotonic, special case.","title":"Treap"},{"location":"ds/treap.html#non-rotate-treap","text":"split : split into two treaps by some key. s.t. keys(left) < < key \\leq \\leq keys(right). merge : merge two treaps into one by priority heapify. Use above two basic operations to retain treap property, we can achieve other tree operations.","title":"Non-rotate treap"},{"location":"ds/treap.html#lazy-range-reverse","text":"split_by_size : as said. However we use treap mostly in this fashion, index [n] implicitly as key to build initial treap. Then doing reverse will destory (index-key)tree property, but (randomized)priority almost ensure balance still. get rank/position of original index after some reverse. method 1. for the chain that node to root, accum left size decided by each edge is left or right. method 2. maintain u=min(l,r) and erase min when monotonic, special case.","title":"Lazy, range reverse"},{"location":"math/crt.html","text":"Solve a a for a \\equiv a_i (\\mod p_i) a \\equiv a_i (\\mod p_i) , coprime \\gcd(p_i,p_j)=1, \\forall i,j \\gcd(p_i,p_j)=1, \\forall i,j . Claim 1. \\exists \\exists unique a (\\mod P) a (\\mod P) , where P = \\prod p_i P = \\prod p_i . Claim 2. a = \\sum a_ib_ib_i' a = \\sum a_ib_ib_i' , where b_i = P/p_i b_i = P/p_i , b_i' = b_i^{-1} (\\mod p_i) b_i' = b_i^{-1} (\\mod p_i) . Extended crt \u00b6 Fold with start (0,1) (0,1) , (a,p) (a,p) by next (a_1,p_1) (a_1,p_1) . Claim. a := a + p p' \\dfrac{a_1-a}{\\gcd(p,p_1)} a := a + p p' \\dfrac{a_1-a}{\\gcd(p,p_1)} , when a_1-a \\equiv 0(\\mod g) a_1-a \\equiv 0(\\mod g) . Proof. Replace pp'=g-p_1p_1' pp'=g-p_1p_1' , result symmetry form a_1 + (0 \\mod p_1) a_1 + (0 \\mod p_1) .","title":"Chinese remainder theorem"},{"location":"math/crt.html#extended-crt","text":"Fold with start (0,1) (0,1) , (a,p) (a,p) by next (a_1,p_1) (a_1,p_1) . Claim. a := a + p p' \\dfrac{a_1-a}{\\gcd(p,p_1)} a := a + p p' \\dfrac{a_1-a}{\\gcd(p,p_1)} , when a_1-a \\equiv 0(\\mod g) a_1-a \\equiv 0(\\mod g) . Proof. Replace pp'=g-p_1p_1' pp'=g-p_1p_1' , result symmetry form a_1 + (0 \\mod p_1) a_1 + (0 \\mod p_1) .","title":"Extended crt"},{"location":"math/dft.html","text":"Usage \u00b6 Convolution in O( n\\log n n\\log n ). Notations \u00b6 Polynomial a(x) = \\sum_{i=0}^{n-1} a_i x^i a(x) = \\sum_{i=0}^{n-1} a_i x^i . Coefficients a = (a_0,\\cdots, a_{n-1}) a = (a_0,\\cdots, a_{n-1}) . n-th root of unity \\omega=\\omega_n: \\omega^n = 1 \\omega=\\omega_n: \\omega^n = 1 . Transform \\text{DFT}(a) = \\mathcal{F}(a) = (a(\\omega^0),\\cdots, a(\\omega^{n-1})) = a(\\omega..) \\text{DFT}(a) = \\mathcal{F}(a) = (a(\\omega^0),\\cdots, a(\\omega^{n-1})) = a(\\omega..) . Convolution \\mathcal{F}(a * b) = (a * b)(\\omega..) = (a(\\omega^k)b(\\omega^k),\\cdots) = a(\\omega..)b(\\omega..) = \\mathcal{F}(a)\\mathcal{F}(b) \\mathcal{F}(a * b) = (a * b)(\\omega..) = (a(\\omega^k)b(\\omega^k),\\cdots) = a(\\omega..)b(\\omega..) = \\mathcal{F}(a)\\mathcal{F}(b) . Matrix view \\mathcal{F}(a) = \\Omega a \\mathcal{F}(a) = \\Omega a , where \\Omega = (\\omega^{ij}) \\Omega = (\\omega^{ij}) . Inverse \\mathcal{F}^{-1}: \\Omega^{-1} = \\dfrac{1}{n} \\Omega^* \\mathcal{F}^{-1}: \\Omega^{-1} = \\dfrac{1}{n} \\Omega^* . Butterfly \u00b6 Lemma. Assume n n even. a(x) = a_{even}(x^2) + x a_{odd} (x^2) \\\\\\\\ \\omega_d^{dk} = \\omega^k, \\omega_n^{n/2} = \\omega_2^1 = -1 \\\\\\\\ \\omega^{k+n/2} = -\\omega^k \\\\\\\\ (\\omega^{k + n/2})^2 = (\\omega^k)^2 = \\omega_{1/2}^k a(x) = a_{even}(x^2) + x a_{odd} (x^2) \\\\\\\\ \\omega_d^{dk} = \\omega^k, \\omega_n^{n/2} = \\omega_2^1 = -1 \\\\\\\\ \\omega^{k+n/2} = -\\omega^k \\\\\\\\ (\\omega^{k + n/2})^2 = (\\omega^k)^2 = \\omega_{1/2}^k FFT. a(\\omega^k) = a_{even}(\\omega_{1/2}^k) + \\omega^k a_{odd} (\\omega_{1/2}^k) \\\\\\\\ a(\\omega^{k+n/2}) = a_{even}(\\omega_{1/2}^k) - \\omega^k a_{odd} (\\omega_{1/2}^k) a(\\omega^k) = a_{even}(\\omega_{1/2}^k) + \\omega^k a_{odd} (\\omega_{1/2}^k) \\\\\\\\ a(\\omega^{k+n/2}) = a_{even}(\\omega_{1/2}^k) - \\omega^k a_{odd} (\\omega_{1/2}^k) radix 2 trick. bit-reversal permutation. Groups \u00b6 Complex \u00b6 \\omega = e^{-\\dfrac{2\\pi i}{n}} \\omega = e^{-\\dfrac{2\\pi i}{n}} . NTT \u00b6 \\omega = g^c, p = cn+1 \\omega = g^c, p = cn+1 : generator/primitive root . FWHT \u00b6 Generalize \\sum \\sum 's + in x^{k+j} x^{k+j} with &,^,| . properties \u00b6 No need bit-reversal nor generator. let H_m H_m be the tranform matrix c.to n=2^m n=2^m . H_m = H_1 \\otimes H_{m-1} H_m = H_1 \\otimes H_{m-1} . H_1 H_1 could not be unique, as long as it stores recoverable information. Xor \u00b6 H_1 = (|+\\rangle, |-\\rangle) = \\dfrac{1}{\\sqrt{2}} \\begin{pmatrix} 1 & 1 \\\\\\\\ 1 & -1\\end{pmatrix} H_1 = (|+\\rangle, |-\\rangle) = \\dfrac{1}{\\sqrt{2}} \\begin{pmatrix} 1 & 1 \\\\\\\\ 1 & -1\\end{pmatrix} . H_m^{-1} = H_m H_m^{-1} = H_m , H_m^2 = I H_m^2 = I . And \u00b6 H_1 = \\begin{pmatrix} 1 & 1 \\\\\\\\ 0 & 1\\end{pmatrix} H_1 = \\begin{pmatrix} 1 & 1 \\\\\\\\ 0 & 1\\end{pmatrix} . \\Leftrightarrow \\Leftrightarrow Zeta superset. Or \u00b6 H_1 = \\begin{pmatrix} 1 & 0 \\\\\\\\ 1 & 1\\end{pmatrix} H_1 = \\begin{pmatrix} 1 & 0 \\\\\\\\ 1 & 1\\end{pmatrix} . \\Leftrightarrow \\Leftrightarrow Zeta.","title":"Discrete fourier transform"},{"location":"math/dft.html#usage","text":"Convolution in O( n\\log n n\\log n ).","title":"Usage"},{"location":"math/dft.html#notations","text":"Polynomial a(x) = \\sum_{i=0}^{n-1} a_i x^i a(x) = \\sum_{i=0}^{n-1} a_i x^i . Coefficients a = (a_0,\\cdots, a_{n-1}) a = (a_0,\\cdots, a_{n-1}) . n-th root of unity \\omega=\\omega_n: \\omega^n = 1 \\omega=\\omega_n: \\omega^n = 1 . Transform \\text{DFT}(a) = \\mathcal{F}(a) = (a(\\omega^0),\\cdots, a(\\omega^{n-1})) = a(\\omega..) \\text{DFT}(a) = \\mathcal{F}(a) = (a(\\omega^0),\\cdots, a(\\omega^{n-1})) = a(\\omega..) . Convolution \\mathcal{F}(a * b) = (a * b)(\\omega..) = (a(\\omega^k)b(\\omega^k),\\cdots) = a(\\omega..)b(\\omega..) = \\mathcal{F}(a)\\mathcal{F}(b) \\mathcal{F}(a * b) = (a * b)(\\omega..) = (a(\\omega^k)b(\\omega^k),\\cdots) = a(\\omega..)b(\\omega..) = \\mathcal{F}(a)\\mathcal{F}(b) . Matrix view \\mathcal{F}(a) = \\Omega a \\mathcal{F}(a) = \\Omega a , where \\Omega = (\\omega^{ij}) \\Omega = (\\omega^{ij}) . Inverse \\mathcal{F}^{-1}: \\Omega^{-1} = \\dfrac{1}{n} \\Omega^* \\mathcal{F}^{-1}: \\Omega^{-1} = \\dfrac{1}{n} \\Omega^* .","title":"Notations"},{"location":"math/dft.html#butterfly","text":"Lemma. Assume n n even. a(x) = a_{even}(x^2) + x a_{odd} (x^2) \\\\\\\\ \\omega_d^{dk} = \\omega^k, \\omega_n^{n/2} = \\omega_2^1 = -1 \\\\\\\\ \\omega^{k+n/2} = -\\omega^k \\\\\\\\ (\\omega^{k + n/2})^2 = (\\omega^k)^2 = \\omega_{1/2}^k a(x) = a_{even}(x^2) + x a_{odd} (x^2) \\\\\\\\ \\omega_d^{dk} = \\omega^k, \\omega_n^{n/2} = \\omega_2^1 = -1 \\\\\\\\ \\omega^{k+n/2} = -\\omega^k \\\\\\\\ (\\omega^{k + n/2})^2 = (\\omega^k)^2 = \\omega_{1/2}^k FFT. a(\\omega^k) = a_{even}(\\omega_{1/2}^k) + \\omega^k a_{odd} (\\omega_{1/2}^k) \\\\\\\\ a(\\omega^{k+n/2}) = a_{even}(\\omega_{1/2}^k) - \\omega^k a_{odd} (\\omega_{1/2}^k) a(\\omega^k) = a_{even}(\\omega_{1/2}^k) + \\omega^k a_{odd} (\\omega_{1/2}^k) \\\\\\\\ a(\\omega^{k+n/2}) = a_{even}(\\omega_{1/2}^k) - \\omega^k a_{odd} (\\omega_{1/2}^k) radix 2 trick. bit-reversal permutation.","title":"Butterfly"},{"location":"math/dft.html#groups","text":"","title":"Groups"},{"location":"math/dft.html#complex","text":"\\omega = e^{-\\dfrac{2\\pi i}{n}} \\omega = e^{-\\dfrac{2\\pi i}{n}} .","title":"Complex"},{"location":"math/dft.html#ntt","text":"\\omega = g^c, p = cn+1 \\omega = g^c, p = cn+1 : generator/primitive root .","title":"NTT"},{"location":"math/dft.html#fwht","text":"Generalize \\sum \\sum 's + in x^{k+j} x^{k+j} with &,^,| .","title":"FWHT"},{"location":"math/dft.html#properties","text":"No need bit-reversal nor generator. let H_m H_m be the tranform matrix c.to n=2^m n=2^m . H_m = H_1 \\otimes H_{m-1} H_m = H_1 \\otimes H_{m-1} . H_1 H_1 could not be unique, as long as it stores recoverable information.","title":"properties"},{"location":"math/dft.html#xor","text":"H_1 = (|+\\rangle, |-\\rangle) = \\dfrac{1}{\\sqrt{2}} \\begin{pmatrix} 1 & 1 \\\\\\\\ 1 & -1\\end{pmatrix} H_1 = (|+\\rangle, |-\\rangle) = \\dfrac{1}{\\sqrt{2}} \\begin{pmatrix} 1 & 1 \\\\\\\\ 1 & -1\\end{pmatrix} . H_m^{-1} = H_m H_m^{-1} = H_m , H_m^2 = I H_m^2 = I .","title":"Xor"},{"location":"math/dft.html#and","text":"H_1 = \\begin{pmatrix} 1 & 1 \\\\\\\\ 0 & 1\\end{pmatrix} H_1 = \\begin{pmatrix} 1 & 1 \\\\\\\\ 0 & 1\\end{pmatrix} . \\Leftrightarrow \\Leftrightarrow Zeta superset.","title":"And"},{"location":"math/dft.html#or","text":"H_1 = \\begin{pmatrix} 1 & 0 \\\\\\\\ 1 & 1\\end{pmatrix} H_1 = \\begin{pmatrix} 1 & 0 \\\\\\\\ 1 & 1\\end{pmatrix} . \\Leftrightarrow \\Leftrightarrow Zeta.","title":"Or"},{"location":"math/exgcd.html","text":"Solve ax+by = \\gcd(a,b) ax+by = \\gcd(a,b) . With implicitly knowing solution bx' + (a \\mod b)y' = g bx' + (a \\mod b)y' = g , and with a\\mod b = a - \\lfloor\\dfrac{a}{b}\\rfloor b a\\mod b = a - \\lfloor\\dfrac{a}{b}\\rfloor b . Rearrange coefficients: \\Rightarrow x = y', y = x' - y'\\cdot \\lfloor\\dfrac{a}{b}\\rfloor \\Rightarrow x = y', y = x' - y'\\cdot \\lfloor\\dfrac{a}{b}\\rfloor","title":"Extended gcd"},{"location":"math/sieve.html","text":"Linear \u00b6 Break when hit least prime factor. Claim. Each composite sieved once corresponding to its least prime. Multiplicative function : f(mn) = f(m)f(n) f(mn) = f(m)f(n) , for coprime m,n m,n . f(ip) f(ip) \\phi \\phi \\mu \\mu \\sigma_k \\sigma_k e_k e_k p\\nmid i p\\nmid i (p-1)\\phi(i) (p-1)\\phi(i) -\\mu(i) -\\mu(i) (1+p^k)\\sigma_k(i) (1+p^k)\\sigma_k(i) 1+p^k 1+p^k p\\mid i p\\mid i p\\phi(i) p\\phi(i) 0 0 \\sigma_k(i) e_k(ip)/e_k(i) \\sigma_k(i) e_k(ip)/e_k(i) 1 + e_k(i)*p^k 1 + e_k(i)*p^k Where e_{k,p}(p^c) = 1 + p^k + p^{2k} + \\cdots + p^{ck} e_{k,p}(p^c) = 1 + p^k + p^{2k} + \\cdots + p^{ck} , a non-multy helper function. Thus we can build above functions in linear time. Prefix of multiplicative functions \u00b6 Usage. Find F(n)=\\sum f(i) F(n)=\\sum f(i) . Dirichlet ring . Divisor sum identities . When f*g f*g is easy to calculate: \\begin{align} \\sum_{i=1}^n (f*g)(i) = \\sum_{i=1}^n F\\left(\\left\\lfloor \\dfrac{n}{i} \\right\\rfloor\\right) g(i) \\\\\\\\ \\Rightarrow F(n) \\sim (F\\left(\\left\\lfloor \\dfrac{n}{2} \\right\\rfloor\\right),\\cdots) \\end{align} \\begin{align} \\sum_{i=1}^n (f*g)(i) = \\sum_{i=1}^n F\\left(\\left\\lfloor \\dfrac{n}{i} \\right\\rfloor\\right) g(i) \\\\\\\\ \\Rightarrow F(n) \\sim (F\\left(\\left\\lfloor \\dfrac{n}{2} \\right\\rfloor\\right),\\cdots) \\end{align} On prime factorization \u00b6 Implicitly ignore f(i=1)=1 f(i=1)=1 . Usage. Find F F when f(p^c) f(p^c) easy to calculate. Notation. p_1=2,p_2=3,p_3=5,... p_1=2,p_2=3,p_3=5,... ; p_s = \\max \\{p: p \\leq \\sqrt{n} \\} p_s = \\max \\{p: p \\leq \\sqrt{n} \\} . Define. S_k = \\{x: p_i\\nmid x, \\forall i\\leq k\\} S_k = \\{x: p_i\\nmid x, \\forall i\\leq k\\} . i.e. remain number sieved after first k k primes. $$ [n] = S_0 \\supset S_1 = {\\text{odd number}} \\supset S_2 \\supset \\cdots S_s = \\{ p: p > \\sqrt{n} \\} $$ Zhou \u00b6 Let F_k(n) = \\sum_{i\\in S_k} f(i) F_k(n) = \\sum_{i\\in S_k} f(i) . Recurrence relation: \\begin{align} F(n) &= F_0(n) = \\sum_i f(i) \\\\ F_k(n) &= F_{k-1}(n) - f(p_k) F_{k-1} \\left(\\left\\lfloor \\dfrac{n}{p_k} \\right\\rfloor\\right) \\\\ &= \\begin{cases} F_{k-1}(n), p_k^2 > n \\\\ \\cdots \\end{cases} \\end{align} Thus we can calculate $$ \\sum_{\\exists p > \\sqrt{n}, p\\mid i} f(i) = \\sum_{i=1}^{\\sqrt{n}} f(i)F_{s}\\left(\\left\\lfloor\\dfrac{n}{i} \\right\\rfloor \\right) $$ Similarily we can define H_k(n)= \\sum_{i \\sim (p_k..p_s]} f(i) H_k(n)= \\sum_{i \\sim (p_k..p_s]} f(i) , to calculate remain part. Min_25 \u00b6 Usage. Count number of primes, \\pi(n) \\pi(n) . Let G_k(n) = \\sum_{S_k \\cup P} g(i) G_k(n) = \\sum_{S_k \\cup P} g(i) . Similarily: $$ G_k(n) = G_{k-1}(n) - g(p_k) \\left(G_{k-1} \\left(\\left\\lfloor \\dfrac{n}{p_k} \\right\\rfloor\\right) - G_{k-1}(p_{k-1}) \\right) $$ Set g=1 g=1 , thus \\pi(n) = G_s(n) \\pi(n) = G_s(n) . Meissel\u2013Lehmer \u00b6","title":"Sieve"},{"location":"math/sieve.html#linear","text":"Break when hit least prime factor. Claim. Each composite sieved once corresponding to its least prime. Multiplicative function : f(mn) = f(m)f(n) f(mn) = f(m)f(n) , for coprime m,n m,n . f(ip) f(ip) \\phi \\phi \\mu \\mu \\sigma_k \\sigma_k e_k e_k p\\nmid i p\\nmid i (p-1)\\phi(i) (p-1)\\phi(i) -\\mu(i) -\\mu(i) (1+p^k)\\sigma_k(i) (1+p^k)\\sigma_k(i) 1+p^k 1+p^k p\\mid i p\\mid i p\\phi(i) p\\phi(i) 0 0 \\sigma_k(i) e_k(ip)/e_k(i) \\sigma_k(i) e_k(ip)/e_k(i) 1 + e_k(i)*p^k 1 + e_k(i)*p^k Where e_{k,p}(p^c) = 1 + p^k + p^{2k} + \\cdots + p^{ck} e_{k,p}(p^c) = 1 + p^k + p^{2k} + \\cdots + p^{ck} , a non-multy helper function. Thus we can build above functions in linear time.","title":"Linear"},{"location":"math/sieve.html#prefix-of-multiplicative-functions","text":"Usage. Find F(n)=\\sum f(i) F(n)=\\sum f(i) . Dirichlet ring . Divisor sum identities . When f*g f*g is easy to calculate: \\begin{align} \\sum_{i=1}^n (f*g)(i) = \\sum_{i=1}^n F\\left(\\left\\lfloor \\dfrac{n}{i} \\right\\rfloor\\right) g(i) \\\\\\\\ \\Rightarrow F(n) \\sim (F\\left(\\left\\lfloor \\dfrac{n}{2} \\right\\rfloor\\right),\\cdots) \\end{align} \\begin{align} \\sum_{i=1}^n (f*g)(i) = \\sum_{i=1}^n F\\left(\\left\\lfloor \\dfrac{n}{i} \\right\\rfloor\\right) g(i) \\\\\\\\ \\Rightarrow F(n) \\sim (F\\left(\\left\\lfloor \\dfrac{n}{2} \\right\\rfloor\\right),\\cdots) \\end{align}","title":"Prefix of multiplicative functions"},{"location":"math/sieve.html#on-prime-factorization","text":"Implicitly ignore f(i=1)=1 f(i=1)=1 . Usage. Find F F when f(p^c) f(p^c) easy to calculate. Notation. p_1=2,p_2=3,p_3=5,... p_1=2,p_2=3,p_3=5,... ; p_s = \\max \\{p: p \\leq \\sqrt{n} \\} p_s = \\max \\{p: p \\leq \\sqrt{n} \\} . Define. S_k = \\{x: p_i\\nmid x, \\forall i\\leq k\\} S_k = \\{x: p_i\\nmid x, \\forall i\\leq k\\} . i.e. remain number sieved after first k k primes. $$ [n] = S_0 \\supset S_1 = {\\text{odd number}} \\supset S_2 \\supset \\cdots S_s = \\{ p: p > \\sqrt{n} \\} $$","title":"On prime factorization"},{"location":"math/sieve.html#zhou","text":"Let F_k(n) = \\sum_{i\\in S_k} f(i) F_k(n) = \\sum_{i\\in S_k} f(i) . Recurrence relation: \\begin{align} F(n) &= F_0(n) = \\sum_i f(i) \\\\ F_k(n) &= F_{k-1}(n) - f(p_k) F_{k-1} \\left(\\left\\lfloor \\dfrac{n}{p_k} \\right\\rfloor\\right) \\\\ &= \\begin{cases} F_{k-1}(n), p_k^2 > n \\\\ \\cdots \\end{cases} \\end{align} Thus we can calculate $$ \\sum_{\\exists p > \\sqrt{n}, p\\mid i} f(i) = \\sum_{i=1}^{\\sqrt{n}} f(i)F_{s}\\left(\\left\\lfloor\\dfrac{n}{i} \\right\\rfloor \\right) $$ Similarily we can define H_k(n)= \\sum_{i \\sim (p_k..p_s]} f(i) H_k(n)= \\sum_{i \\sim (p_k..p_s]} f(i) , to calculate remain part.","title":"Zhou"},{"location":"math/sieve.html#min_25","text":"Usage. Count number of primes, \\pi(n) \\pi(n) . Let G_k(n) = \\sum_{S_k \\cup P} g(i) G_k(n) = \\sum_{S_k \\cup P} g(i) . Similarily: $$ G_k(n) = G_{k-1}(n) - g(p_k) \\left(G_{k-1} \\left(\\left\\lfloor \\dfrac{n}{p_k} \\right\\rfloor\\right) - G_{k-1}(p_{k-1}) \\right) $$ Set g=1 g=1 , thus \\pi(n) = G_s(n) \\pi(n) = G_s(n) .","title":"Min_25"},{"location":"math/sieve.html#meissellehmer","text":"","title":"Meissel\u2013Lehmer"},{"location":"string/suffix_array.html","text":"Usage \u00b6 Sort suffix strings s[i..] of s , store i s in sa . View. Suffix trie/tree, by the help of lcp array. Append 0 to s , thus could treat length <k <k still be k k as cyclic string. k=1,2,4,8... k=1,2,4,8... , sort all length =k =k . By compare (i, i+k) as key corresponding to (s[i..i+k], s[i+k..i+2k]) . O( n\\log^2 n n\\log^2 n ). Radix sort (i,i+k) by counting sort. O( n\\log n n\\log n ). Kasai's . Build lcp/height array, i.e. lcp of adjacents(rank). Claim. Adjacents(original)'s lcp(i+1) >= lcp(i)-1 , where lcp(i) = lcp[rk[i]] . Claim 1. lcp of rank l and r is \\min_{i=l..r} \\text{lcp}[i] \\min_{i=l..r} \\text{lcp}[i] . Applications \u00b6 #distinct substrings. i.e. #nodes in trie. = n(n+1)/2 - \\sum_i \\text{lcp}[i] = n(n+1)/2 - \\sum_i \\text{lcp}[i] . Longest length among substrings occurence > k > k . = \\max_i \\min \\text{lcp}[i..i+k] = \\max_i \\min \\text{lcp}[i..i+k] . Lcp of 3 or more strings. Concat S_1\\#_1 S_2\\#_2 S_3 \\#_3 S_1\\#_1 S_2\\#_2 S_3 \\#_3 . Z's algorithm also work.","title":"Suffix array"},{"location":"string/suffix_array.html#usage","text":"Sort suffix strings s[i..] of s , store i s in sa . View. Suffix trie/tree, by the help of lcp array. Append 0 to s , thus could treat length <k <k still be k k as cyclic string. k=1,2,4,8... k=1,2,4,8... , sort all length =k =k . By compare (i, i+k) as key corresponding to (s[i..i+k], s[i+k..i+2k]) . O( n\\log^2 n n\\log^2 n ). Radix sort (i,i+k) by counting sort. O( n\\log n n\\log n ). Kasai's . Build lcp/height array, i.e. lcp of adjacents(rank). Claim. Adjacents(original)'s lcp(i+1) >= lcp(i)-1 , where lcp(i) = lcp[rk[i]] . Claim 1. lcp of rank l and r is \\min_{i=l..r} \\text{lcp}[i] \\min_{i=l..r} \\text{lcp}[i] .","title":"Usage"},{"location":"string/suffix_array.html#applications","text":"#distinct substrings. i.e. #nodes in trie. = n(n+1)/2 - \\sum_i \\text{lcp}[i] = n(n+1)/2 - \\sum_i \\text{lcp}[i] . Longest length among substrings occurence > k > k . = \\max_i \\min \\text{lcp}[i..i+k] = \\max_i \\min \\text{lcp}[i..i+k] . Lcp of 3 or more strings. Concat S_1\\#_1 S_2\\#_2 S_3 \\#_3 S_1\\#_1 S_2\\#_2 S_3 \\#_3 . Z's algorithm also work.","title":"Applications"}]}